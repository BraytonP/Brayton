{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "33a010f5",
   "metadata": {},
   "outputs": [],
   "source": [
    "#limite de 100 jours pour envahir.\n",
    "#11 villes principales :Kyiv,Chernihiv,Kharkiv,Lugansk,Mykolaiv,Dnipro,Sumy,Vinnystsia,Rivne,Lviv,Chernivtsi\n",
    "#3 zones de difficulté\n",
    "#zone 1 (jaune): Lugansk,Sumy,Kharkiv,Rivne,Lviv,Chernivtsi (-15% des troupes ennemies)\n",
    "#zone 2 (orange): Dnipro, Mykolaiv,chernihiv Vinnystsia (-25% des troupes ennemies)\n",
    "#zone 3 (rouge): Kyiv (-50% des troupes ennemies)\n",
    "#La guerre est gagnee si la capitale tombe et si l'ennemi a encore des soldats dans son armee\n",
    "#On supose que l'ennemi est la Russie donc il doit envahir par l'est (sans passer par la Bielorussie)\n",
    "#Le but étant d'arriver à Kyiv donc de se diriger vers l'ouest. Par conséquent toute les villes à l'est de la progression Russe ne font plus partie des options des villes à envahir.\n",
    "#Il entre dans une ville de facon aleatoire\n",
    "#Il peut rentrer seulement dans les villes qui lui sont adjacentes\n",
    "# La zone entre Dnipro et Kyiv engendre des pertes considerables (-25%) ce qui oblige les soldats à la contourner\n",
    "#Temps de siege zone 1 = 10 jours\n",
    "#Temps de siege zone 2 = 25 jours \n",
    "#Temps de siege zone 3 = 50 jours"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "c3db1042",
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import shapefile as shp\n",
    "import matplotlib.pyplot as plt \n",
    "import seaborn as sns\n",
    "import glob\n",
    "import os\n",
    "import csv\n",
    "from PIL import Image\n",
    "\n",
    "\n",
    "sns.set(style=\"whitegrid\",palette='bright',color_codes=True) \n",
    "sns.mpl.rc(\"figure\", figsize=(10,6))\n",
    "shp_path=\"/Users/adam/Downloads/UKR_adm1/UKR_adm1.shp\"\n",
    "sf=shp.Reader(shp_path)\n",
    "len(sf.shapes())\n",
    "sf.records()\n",
    "\n",
    "def read_shapefile(sf):\n",
    "    fields = [x[0] for x in sf.fields][1:]\n",
    "    records = [list(i) for i in sf.records()]\n",
    "    shps = [s.points for s in sf.shapes()]\n",
    "    df = pd.DataFrame(columns=fields, data=records)\n",
    "    df = df.assign(coords=shps)\n",
    "    return df\n",
    "\n",
    "df=read_shapefile(sf)\n",
    "\n",
    "def plot_shape(id, s=None):\n",
    "    plt.figure()\n",
    "    ax = plt.axes()\n",
    "    ax.set_aspect('equal')\n",
    "\n",
    "    shape_ex = sf.shape(id)\n",
    "\n",
    "    x_lon = np.zeros((len(shape_ex.points),1))\n",
    "\n",
    "    y_lat = np.zeros((len(shape_ex.points),1))\n",
    "    for ip in range(len(shape_ex.points)):\n",
    "        x_lon[ip] = shape_ex.points[ip][0]\n",
    "        y_lat[ip] = shape_ex.points[ip][1]\n",
    "\n",
    "    plt.plot(x_lon,y_lat) \n",
    "    x0 = np.mean(x_lon)\n",
    "    y0 = np.mean(y_lat)\n",
    "    plt.text(x0, y0, s, fontsize=10)\n",
    "\n",
    "    plt.xlim(shape_ex.bbox[0],shape_ex.bbox[2])\n",
    "    return x0, y0\n",
    "\n",
    "#It's with the ID's of the cities\n",
    "def plot_map(sf, x_lim = None, y_lim = None, figsize = (11,8)):\n",
    "    plt.figure(figsize = figsize)\n",
    "    id=0\n",
    "    for shape in sf.shapeRecords():\n",
    "        x = [i[0] for i in shape.shape.points[:]]\n",
    "        y = [i[1] for i in shape.shape.points[:]]\n",
    "        plt.plot(x, y, 'k')\n",
    "        \n",
    "        if (x_lim == None) & (y_lim == None):\n",
    "            x0 = np.mean(x)\n",
    "            y0 = np.mean(y)\n",
    "            plt.text(x0, y0, df.NAME_1[id], fontsize=10)\n",
    "        id = id+1\n",
    "    \n",
    "    if (x_lim != None) & (y_lim != None):     \n",
    "        plt.xlim(x_lim)\n",
    "        plt.ylim(y_lim)\n",
    "    \n",
    "    return None\n",
    "\n",
